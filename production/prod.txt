# === PROJECT STRUCTURE ===
"""
banking-chain-prod/
├── app/
│   ├── __init__.py
│   ├── main.py                    # FastAPI app entry point
│   ├── config.py                  # Configuration settings
│   ├── models/
│   │   ├── __init__.py
│   │   ├── request_models.py      # Pydantic request models
│   │   └── response_models.py     # Pydantic response models
│   ├── services/
│   │   ├── __init__.py
│   │   ├── banking_chain.py       # Core banking logic
│   │   ├── rate_limiter.py        # Rate limiting service
│   │   ├── cache_manager.py       # Cache management
│   │   └── ai_clients.py          # AI API clients
│   ├── routers/
│   │   ├── __init__.py
│   │   ├── banking.py             # Banking endpoints
│   │   └── health.py              # Health check endpoints
│   ├── middleware/
│   │   ├── __init__.py
│   │   ├── auth.py                # Authentication middleware
│   │   ├── logging.py             # Logging middleware
│   │   └── cors.py                # CORS middleware
│   ├── utils/
│   │   ├── __init__.py
│   │   ├── security.py            # Security utilities
│   │   ├── validators.py          # Input validation
│   │   └── audit.py               # Audit logging
│   └── database/
│       ├── __init__.py
│       ├── connection.py          # Database connection
│       └── models.py              # Database models
├── infrastructure/
│   ├── docker/
│   │   ├── Dockerfile
│   │   └── docker-compose.yml
│   ├── kubernetes/
│   │   ├── deployment.yaml
│   │   ├── service.yaml
│   │   ├── configmap.yaml
│   │   └── ingress.yaml
│   └── terraform/
│       ├── main.tf
│       └── variables.tf
├── tests/
│   ├── __init__.py
│   ├── test_banking_chain.py
│   └── test_api.py
├── scripts/
│   ├── deploy.sh
│   └── health-check.sh
├── requirements.txt
├── .env.example
└── README.md
"""

# === app/main.py ===
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.trustedhost import TrustedHostMiddleware
import time
import logging

from app.config import settings
from app.routers import banking, health
from app.middleware.logging import setup_logging
from app.services.banking_chain import BankingChainService
from app.services.cache_manager import CacheManager

# Initialize FastAPI app
app = FastAPI(
    title="Banking AI Chain API",
    description="Production-ready banking recommendation system",
    version="1.0.0",
    docs_url="/docs" if settings.APP_ENV != "production" else None
)

# Setup logging
setup_logging()
logger = logging.getLogger(__name__)

# Add middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.CORS_ORIGINS,
    allow_credentials=True,
    allow_methods=["GET", "POST"],
    allow_headers=["*"],
)

app.add_middleware(
    TrustedHostMiddleware,
    allowed_hosts=settings.ALLOWED_HOSTS
)

# Include routers
app.include_router(health.router, prefix="/health", tags=["health"])
app.include_router(banking.router, prefix="/api/v1", tags=["banking"])

# Global services
banking_service = BankingChainService()
cache_manager = CacheManager()

@app.on_event("startup")
async def startup_event():
    app.state.start_time = time.time()
    await banking_service.initialize()
    await cache_manager.initialize()
    logger.info("Banking Chain API started successfully")

@app.on_event("shutdown")
async def shutdown_event():
    await banking_service.cleanup()
    await cache_manager.cleanup()
    logger.info("Banking Chain API shutdown complete")

# === app/config.py ===
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    # Application
    APP_ENV: str = "development"
    DEBUG: bool = False
    LOG_LEVEL: str = "INFO"
    
    # Database
    DATABASE_URL: str = "postgresql://user:pass@localhost:5432/banking_prod"
    DATABASE_POOL_SIZE: int = 20
    DATABASE_MAX_OVERFLOW: int = 30
    
    # APIs
    OPENAI_API_KEY: str
    ANTHROPIC_API_KEY: str
    API_RATE_LIMIT: int = 100
    API_TIMEOUT: int = 30
    
    # Security
    SECRET_KEY: str
    JWT_SECRET_KEY: str
    CORS_ORIGINS: List[str] = ["http://localhost:3000"]
    ALLOWED_HOSTS: List[str] = ["localhost", "127.0.0.1"]
    
    # Infrastructure
    REDIS_URL: str = "redis://localhost:6379"
    SENTRY_DSN: str = ""
    
    # Banking Compliance
    ENCRYPTION_KEY: str
    AUDIT_LOG_ENABLED: bool = True
    PCI_COMPLIANCE_MODE: bool = False
    
    class Config:
        env_file = ".env"

settings = Settings()

# === app/models/request_models.py ===
from pydantic import BaseModel, Field
from typing import Optional

class BankingRequest(BaseModel):
    customer_data: str = Field(..., min_length=10, max_length=1000)
    user_id: Optional[str] = None
    session_id: Optional[str] = None
    
    class Config:
        schema_extra = {
            "example": {
                "customer_data": "25-year-old software engineer, salary $75,000, looking to buy first home",
                "user_id": "user123",
                "session_id": "session456"
            }
        }

# === app/models/response_models.py ===
from pydantic import BaseModel
from datetime import datetime
from typing import Dict, Any

class BankingResponse(BaseModel):
    recommendations: str
    risk_analysis: str
    processing_time: float
    timestamp: datetime
    session_id: str

class HealthResponse(BaseModel):
    status: str
    timestamp: datetime
    version: str
    services: Dict[str, str]
    metrics: Dict[str, Any]

# === app/services/banking_chain.py ===
import asyncio
import logging
from typing import Dict, Any
from app.services.ai_clients import OpenAIClient, AnthropicClient
from app.utils.security import encrypt_data, decrypt_data
from app.utils.audit import log_audit_event

logger = logging.getLogger(__name__)

class BankingChainService:
    def __init__(self):
        self.openai_client = OpenAIClient()
        self.anthropic_client = AnthropicClient()
        
    async def initialize(self):
        """Initialize AI clients"""
        await self.openai_client.initialize()
        await self.anthropic_client.initialize()
        
    async def cleanup(self):
        """Cleanup resources"""
        await self.openai_client.cleanup()
        await self.anthropic_client.cleanup()
        
    async def process_banking_chain(self, customer_data: str, user_id: str) -> Dict[str, Any]:
        """Process the banking recommendation chain"""
        try:
            # Encrypt sensitive data
            encrypted_data = encrypt_data(customer_data)
            
            # Step 1: Get recommendations from OpenAI
            recommendations = await self.openai_client.get_recommendations(encrypted_data)
            
            # Step 2: Get risk analysis from Claude
            risk_analysis = await self.anthropic_client.analyze_risks(recommendations)
            
            # Audit log
            await log_audit_event(
                user_id=user_id,
                action="banking_recommendation",
                data_hash=hash(customer_data)
            )
            
            return {
                "recommendations": recommendations,
                "risk_analysis": risk_analysis
            }
            
        except Exception as e:
            logger.error(f"Error in banking chain processing: {str(e)}")
            raise

# === app/services/ai_clients.py ===
import asyncio
import logging
from openai import AsyncOpenAI
import anthropic
from app.config import settings

logger = logging.getLogger(__name__)

class OpenAIClient:
    def __init__(self):
        self.client = AsyncOpenAI(api_key=settings.OPENAI_API_KEY)
        
    async def initialize(self):
        """Initialize OpenAI client"""
        logger.info("OpenAI client initialized")
        
    async def cleanup(self):
        """Cleanup OpenAI client"""
        await self.client.close()
        
    async def get_recommendations(self, customer_data: str) -> str:
        """Get banking recommendations from GPT-4"""
        try:
            response = await self.client.chat.completions.create(
                model="gpt-4",
                temperature=0.7,
                timeout=settings.API_TIMEOUT,
                messages=[
                    {"role": "system", "content": "You are a retail banking advisor."},
                    {"role": "user", "content": f"Given this customer info, suggest suitable banking products: {customer_data}"}
                ]
            )
            return response.choices[0].message.content.strip()
            
        except Exception as e:
            logger.error(f"OpenAI API error: {str(e)}")
            raise

class AnthropicClient:
    def __init__(self):
        self.client = anthropic.AsyncAnthropic(api_key=settings.ANTHROPIC_API_KEY)
        
    async def initialize(self):
        """Initialize Anthropic client"""
        logger.info("Anthropic client initialized")
        
    async def cleanup(self):
        """Cleanup Anthropic client"""
        # Anthropic client doesn't need explicit cleanup
        pass
        
    async def analyze_risks(self, recommendations: str) -> str:
        """Analyze risks using Claude"""
        try:
            response = await self.client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=800,
                temperature=0.7,
                timeout=settings.API_TIMEOUT,
                messages=[
                    {"role": "user", "content": f"Please review the following banking product suggestions and identify potential risks: {recommendations}"}
                ]
            )
            return response.content[0].text.strip()
            
        except Exception as e:
            logger.error(f"Anthropic API error: {str(e)}")
            raise

# === app/services/rate_limiter.py ===
import asyncio
import redis.asyncio as redis
from datetime import datetime, timedelta
from app.config import settings

class RateLimiter:
    def __init__(self):
        self.redis_client = redis.from_url(settings.REDIS_URL)
        
    async def check_rate_limit(self, user_id: str) -> bool:
        """Check if user is within rate limits"""
        key = f"rate_limit:{user_id}"
        current_time = datetime.utcnow()
        window_start = current_time - timedelta(minutes=1)
        
        # Count requests in the last minute
        await self.redis_client.zremrangebyscore(key, 0, window_start.timestamp())
        request_count = await self.redis_client.zcard(key)
        
        if request_count >= settings.API_RATE_LIMIT:
            raise Exception("Rate limit exceeded")
            
        # Add current request
        await self.redis_client.zadd(key, {str(current_time): current_time.timestamp()})
        await self.redis_client.expire(key, 60)
        
        return True

# === app/services/cache_manager.py ===
import redis.asyncio as redis
import json
from datetime import timedelta
from app.config import settings

class CacheManager:
    def __init__(self):
        self.redis_client = redis.from_url(settings.REDIS_URL)
        
    async def initialize(self):
        """Initialize cache manager"""
        await self.redis_client.ping()
        
    async def cleanup(self):
        """Cleanup cache manager"""
        await self.redis_client.close()
        
    async def get(self, key: str) -> str:
        """Get value from cache"""
        return await self.redis_client.get(key)
        
    async def set(self, key: str, value: str, expire: timedelta = None):
        """Set value in cache"""
        if expire:
            await self.redis_client.setex(key, int(expire.total_seconds()), value)
        else:
            await self.redis_client.set(key, value)
            
    async def ping(self):
        """Ping Redis to check health"""
        return await self.redis_client.ping()

# === app/routers/banking.py ===
from fastapi import APIRouter, HTTPException, Depends, BackgroundTasks
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
import time
import json
from datetime import datetime, timedelta

from app.models.request_models import BankingRequest
from app.models.response_models import BankingResponse
from app.services.banking_chain import BankingChainService
from app.services.rate_limiter import RateLimiter
from app.services.cache_manager import CacheManager
from app.middleware.auth import verify_token
from app.utils.validators import generate_session_id

router = APIRouter()
security = HTTPBearer()

# Initialize services
banking_service = BankingChainService()
rate_limiter = RateLimiter()
cache_manager = CacheManager()

@router.post("/banking-recommendation", response_model=BankingResponse)
async def get_banking_recommendation(
    request: BankingRequest,
    background_tasks: BackgroundTasks,
    credentials: HTTPAuthorizationCredentials = Depends(security)
):
    """Get banking recommendations with AI chain processing"""
    start_time = time.time()
    
    try:
        # Verify authentication
        user_data = await verify_token(credentials.credentials)
        
        # Rate limiting
        await rate_limiter.check_rate_limit(user_data["user_id"])
        
        # Check cache
        cache_key = f"banking_rec:{hash(request.customer_data)}"
        cached_result = await cache_manager.get(cache_key)
        
        if cached_result:
            return BankingResponse(**json.loads(cached_result))
        
        # Process banking recommendation
        result = await banking_service.process_banking_chain(
            customer_data=request.customer_data,
            user_id=user_data["user_id"]
        )
        
        processing_time = time.time() - start_time
        
        response = BankingResponse(
            recommendations=result["recommendations"],
            risk_analysis=result["risk_analysis"],
            processing_time=processing_time,
            timestamp=datetime.utcnow(),
            session_id=request.session_id or generate_session_id()
        )
        
        # Cache the result
        await cache_manager.set(
            cache_key, 
            response.json(), 
            expire=timedelta(hours=1)
        )
        
        return response
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# === app/routers/health.py ===
from fastapi import APIRouter
from datetime import datetime
from app.models.response_models import HealthResponse
from app.services.cache_manager import CacheManager

router = APIRouter()

@router.get("/", response_model=HealthResponse)
async def health_check():
    """Health check endpoint"""
    cache_manager = CacheManager()
    
    # Check service health
    services = {
        "database": "healthy",  # Implement actual check
        "redis": "healthy" if await cache_manager.ping() else "unhealthy",
        "openai_api": "healthy",  # Implement actual check
        "anthropic_api": "healthy"  # Implement actual check
    }
    
    metrics = {
        "uptime": 3600,  # Implement actual uptime
        "requests_per_minute": 45,
        "error_rate": 0.02,
        "avg_response_time": 1200
    }
    
    status = "healthy" if all(s == "healthy" for s in services.values()) else "degraded"
    
    return HealthResponse(
        status=status,
        timestamp=datetime.utcnow(),
        version="1.0.0",
        services=services,
        metrics=metrics
    )

# === app/middleware/auth.py ===
import jwt
from fastapi import HTTPException
from app.config import settings

async def verify_token(token: str) -> dict:
    """Verify JWT token and return user data"""
    try:
        payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=["HS256"])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

# === app/middleware/logging.py ===
import logging
import sys
from app.config import settings

def setup_logging():
    """Setup application logging"""
    logging.basicConfig(
        level=getattr(logging, settings.LOG_LEVEL),
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        handlers=[
            logging.StreamHandler(sys.stdout),
            logging.FileHandler('app.log')
        ]
    )

# === app/utils/security.py ===
from cryptography.fernet import Fernet
from app.config import settings

def encrypt_data(data: str) -> str:
    """Encrypt sensitive data"""
    f = Fernet(settings.ENCRYPTION_KEY.encode())
    return f.encrypt(data.encode()).decode()

def decrypt_data(encrypted_data: str) -> str:
    """Decrypt sensitive data"""
    f = Fernet(settings.ENCRYPTION_KEY.encode())
    return f.decrypt(encrypted_data.encode()).decode()

# === app/utils/validators.py ===
import uuid

def generate_session_id() -> str:
    """Generate unique session ID"""
    return str(uuid.uuid4())

# === app/utils/audit.py ===
import logging
import json
from datetime import datetime

audit_logger = logging.getLogger("audit")

async def log_audit_event(user_id: str, action: str, data_hash: int):
    """Log audit events for compliance"""
    audit_data = {
        "timestamp": datetime.utcnow().isoformat(),
        "user_id": user_id,
        "action": action,
        "data_hash": data_hash
    }
    audit_logger.info(f"AUDIT: {json.dumps(audit_data)}")

# === infrastructure/docker/Dockerfile ===
"""
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y gcc && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY app/ ./app/

# Create non-root user
RUN useradd --create-home --shell /bin/bash appuser
USER appuser

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

EXPOSE 8000

CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
"""

# === .env.example ===
"""
# Application
APP_ENV=development
DEBUG=false
LOG_LEVEL=INFO

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/banking_prod

# APIs
OPENAI_API_KEY=sk-your-openai-key-here
ANTHROPIC_API_KEY=ant-your-anthropic-key-here
API_RATE_LIMIT=100
API_TIMEOUT=30

# Security
SECRET_KEY=your-super-secret-key-change-in-production
JWT_SECRET_KEY=jwt-secret-change-in-production

# Infrastructure
REDIS_URL=redis://localhost:6379
SENTRY_DSN=https://your-sentry-dsn

# Banking Compliance
ENCRYPTION_KEY=your-32-character-encryption-key
AUDIT_LOG_ENABLED=true
PCI_COMPLIANCE_MODE=false
"""
